<!-- META
{
  "title": "KMP Algorithm - String Pattern Matching",
  "description": "Interactive visualization of the Knuth-Morris-Pratt (KMP) algorithm for efficient string pattern matching with failure function demonstration.",
  "tags": ["Algorithm", "String Matching", "Pattern Matching", "KMP", "Visualization", "Computer Science"],
  "createdAt": "2024-01-20T16:00:00Z",
  "updatedAt": "2024-01-20T16:00:00Z"
}
-->

<div style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; line-height: 1.6; color: #333; max-width: 100%;">
  <h1 style="background: linear-gradient(45deg, #3b82f6, #8b5cf6); background-clip: text; -webkit-background-clip: text; -webkit-text-fill-color: transparent; color: transparent; font-size: 2.5rem; font-weight: bold; margin-bottom: 20px; text-align: center;">
    üîç KMP Algorithm - Pattern Matching
  </h1>

  <div style="background: linear-gradient(135deg, #1e293b 0%, #475569 100%); color: white; padding: 25px; border-radius: 12px; margin-bottom: 30px; box-shadow: 0 10px 25px rgba(0,0,0,0.1);">
    <p style="font-size: 18px; margin: 0; text-align: center;">
      Learn the <strong>Knuth-Morris-Pratt (KMP)</strong> algorithm for efficient string pattern matching with interactive visualization and failure function construction.
    </p>
  </div>

  <!-- Problem Statement -->
  <div style="background: #f8fafc; border-left: 4px solid #3b82f6; padding: 20px; margin: 25px 0; border-radius: 0 8px 8px 0;">
    <h2 style="color: #1e40af; margin-top: 0;">üìã Problem Statement</h2>
    <p style="margin-bottom: 15px;">Given a text string and a pattern string, find all occurrences of the pattern in the text efficiently.</p>
    <div style="background: #e0f2fe; padding: 15px; border-radius: 8px; margin: 15px 0;">
      <strong>Example:</strong><br>
      Text: "ABABDABACDABABCABCABCABCABC"<br>
      Pattern: "ABCABCABC"<br>
      Output: Pattern found at index 15
    </div>
    <div style="background: #fff3cd; padding: 15px; border-radius: 8px; margin: 15px 0; border-left: 4px solid #ffc107;">
      <strong>Why KMP?</strong> Naive pattern matching has O(nm) complexity. KMP achieves O(n+m) by avoiding redundant comparisons using a failure function.
    </div>
  </div>

  <!-- Input Configuration -->
  <div style="background: white; border: 2px solid #e5e7eb; border-radius: 12px; padding: 25px; margin: 25px 0; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
    <h2 style="color: #1f2937; margin-top: 0; text-align: center;">‚öôÔ∏è Configure Input</h2>
    
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
      <div>
        <label style="display: block; font-weight: bold; margin-bottom: 8px; color: #374151;">Text String:</label>
        <input id="textInput" type="text" value="ABABDABACDABABCABCABCABCABC" 
               style="width: 100%; padding: 10px; border: 2px solid #d1d5db; border-radius: 8px; font-family: monospace; font-size: 14px;">
      </div>
      <div>
        <label style="display: block; font-weight: bold; margin-bottom: 8px; color: #374151;">Pattern String:</label>
        <input id="patternInput" type="text" value="ABCABCABC" 
               style="width: 100%; padding: 10px; border: 2px solid #d1d5db; border-radius: 8px; font-family: monospace; font-size: 14px;">
      </div>
    </div>

    <div style="text-align: center;">
      <button id="updateInputBtn" style="background: #3b82f6; color: white; border: none; padding: 10px 20px; border-radius: 8px; cursor: pointer; font-weight: bold;">üîÑ Update Visualization</button>
    </div>
  </div>

  <!-- Failure Function Visualization -->
  <div style="background: white; border: 2px solid #e5e7eb; border-radius: 12px; padding: 25px; margin: 25px 0; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
    <h2 style="color: #1f2937; margin-top: 0; text-align: center;">üèóÔ∏è Failure Function Construction</h2>
    
    <!-- Control Panel for Failure Function -->
    <div style="text-align: center; margin-bottom: 25px;">
      <button id="buildFailureBtn" style="background: #10b981; color: white; border: none; padding: 10px 20px; border-radius: 8px; margin: 5px; cursor: pointer; font-weight: bold;">‚ñ∂Ô∏è Build Failure Function</button>
      <button id="resetFailureBtn" style="background: #ef4444; color: white; border: none; padding: 10px 20px; border-radius: 8px; margin: 5px; cursor: pointer; font-weight: bold;">üîÑ Reset</button>
      <button id="stepFailureBtn" style="background: #8b5cf6; color: white; border: none; padding: 10px 20px; border-radius: 8px; margin: 5px; cursor: pointer; font-weight: bold;">üë£ Step</button>
    </div>

    <!-- Failure Function Step Info -->
    <div id="failureStepInfo" style="background: #f3f4f6; padding: 15px; border-radius: 8px; margin-bottom: 20px; text-align: center; font-weight: bold; color: #374151;">
      Click "Build Failure Function" to start construction
    </div>

    <!-- Failure Function Visualization -->
    <div id="failureVisualization" style="min-height: 200px; padding: 20px; border: 2px dashed #d1d5db; border-radius: 8px; margin-bottom: 20px;">
      <!-- Dynamic failure function content will be inserted here -->
    </div>
  </div>

  <!-- Pattern Matching Visualization -->
  <div style="background: white; border: 2px solid #e5e7eb; border-radius: 12px; padding: 25px; margin: 25px 0; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
    <h2 style="color: #1f2937; margin-top: 0; text-align: center;">üéØ Pattern Matching Visualization</h2>
    
    <!-- Control Panel -->
    <div style="text-align: center; margin-bottom: 25px;">
      <button id="searchBtn" style="background: #10b981; color: white; border: none; padding: 10px 20px; border-radius: 8px; margin: 5px; cursor: pointer; font-weight: bold;">üîç Start Search</button>
      <button id="pauseSearchBtn" style="background: #f59e0b; color: white; border: none; padding: 10px 20px; border-radius: 8px; margin: 5px; cursor: pointer; font-weight: bold;">‚è∏Ô∏è Pause</button>
      <button id="resetSearchBtn" style="background: #ef4444; color: white; border: none; padding: 10px 20px; border-radius: 8px; margin: 5px; cursor: pointer; font-weight: bold;">üîÑ Reset</button>
      <button id="stepSearchBtn" style="background: #8b5cf6; color: white; border: none; padding: 10px 20px; border-radius: 8px; margin: 5px; cursor: pointer; font-weight: bold;">üë£ Step</button>
    </div>

    <!-- Search Step Info -->
    <div id="searchStepInfo" style="background: #f3f4f6; padding: 15px; border-radius: 8px; margin-bottom: 20px; text-align: center; font-weight: bold; color: #374151;">
      Click "Start Search" to begin pattern matching
    </div>

    <!-- Pattern Matching Visualization -->
    <div id="searchVisualization" style="min-height: 300px; padding: 20px; border: 2px dashed #d1d5db; border-radius: 8px; overflow-x: auto;">
      <!-- Dynamic search content will be inserted here -->
    </div>

    <!-- Results Display -->
    <div id="searchResults" style="background: #ecfdf5; border: 2px solid #10b981; border-radius: 8px; padding: 15px; margin-top: 20px; display: none;">
      <h3 style="color: #065f46; margin-top: 0;">üìä Search Results</h3>
      <div id="resultsContent"></div>
    </div>
  </div>

  <!-- Algorithm Explanation -->
  <div style="background: #fef3c7; border-left: 4px solid #f59e0b; padding: 20px; margin: 25px 0; border-radius: 0 8px 8px 0;">
    <h2 style="color: #92400e; margin-top: 0;">üß† How KMP Works</h2>
    
    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px;">
      <div style="background: white; padding: 20px; border-radius: 8px;">
        <h3 style="color: #dc2626; margin-top: 0;">1Ô∏è‚É£ Failure Function</h3>
        <p style="margin: 0; font-size: 14px;">
          Preprocesses the pattern to create an array that stores the length of the longest proper prefix 
          which is also a suffix for each position. This helps skip unnecessary comparisons.
        </p>
      </div>
      
      <div style="background: white; padding: 20px; border-radius: 8px;">
        <h3 style="color: #3b82f6; margin-top: 0;">2Ô∏è‚É£ Smart Sliding</h3>
        <p style="margin: 0; font-size: 14px;">
          When a mismatch occurs, use the failure function to determine how far to slide the pattern, 
          avoiding redundant character comparisons that we know will match.
        </p>
      </div>
      
      <div style="background: white; padding: 20px; border-radius: 8px;">
        <h3 style="color: #10b981; margin-top: 0;">3Ô∏è‚É£ Linear Time</h3>
        <p style="margin: 0; font-size: 14px;">
          Achieves O(n + m) time complexity where n is text length and m is pattern length, 
          compared to O(nm) for naive approach.
        </p>
      </div>
    </div>
  </div>

  <!-- Code Implementation -->
  <div style="background: #1e293b; color: #e2e8f0; padding: 25px; border-radius: 12px; margin: 25px 0;">
    <h2 style="color: #60a5fa; margin-top: 0;">üíª Code Implementation</h2>
    
    <div style="background: #374151; padding: 20px; border-radius: 8px; overflow-x: auto; margin-bottom: 20px;">
      <h3 style="color: #fbbf24; margin-top: 0;">Failure Function Construction</h3>
      <pre style="margin: 0; font-family: 'Monaco', 'Menlo', monospace; font-size: 14px; line-height: 1.5;"><code style="color: #e2e8f0;">function buildFailureFunction(pattern) {
    const failure = new Array(pattern.length).fill(0);
    let j = 0; // length of previous longest prefix suffix
    
    for (let i = 1; i < pattern.length; i++) {
        while (j > 0 && pattern[i] !== pattern[j]) {
            j = failure[j - 1]; // Use failure function to jump back
        }
        
        if (pattern[i] === pattern[j]) {
            j++; // Extend the current prefix suffix
        }
        
        failure[i] = j; // Set failure value for position i
    }
    
    return failure;
}</code></pre>
    </div>

    <div style="background: #374151; padding: 20px; border-radius: 8px; overflow-x: auto;">
      <h3 style="color: #fbbf24; margin-top: 0;">KMP Search Algorithm</h3>
      <pre style="margin: 0; font-family: 'Monaco', 'Menlo', monospace; font-size: 14px; line-height: 1.5;"><code style="color: #e2e8f0;">function kmpSearch(text, pattern) {
    if (pattern.length === 0) return [];
    
    const failure = buildFailureFunction(pattern);
    const matches = [];
    let j = 0; // pattern pointer
    
    for (let i = 0; i < text.length; i++) {
        // Handle mismatches using failure function
        while (j > 0 && text[i] !== pattern[j]) {
            j = failure[j - 1];
        }
        
        // If characters match, advance pattern pointer
        if (text[i] === pattern[j]) {
            j++;
        }
        
        // If we've matched the entire pattern
        if (j === pattern.length) {
            matches.push(i - j + 1); // Record starting position
            j = failure[j - 1]; // Continue searching for more matches
        }
    }
    
    return matches;
}</code></pre>
    </div>
  </div>

  <!-- Complexity Analysis -->
  <div style="background: #ecf3ff; border-left: 4px solid #3b82f6; padding: 20px; margin: 25px 0; border-radius: 0 8px 8px 0;">
    <h2 style="color: #1e40af; margin-top: 0;">üìà Complexity Analysis</h2>
    
    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px;">
      <div style="background: white; padding: 15px; border-radius: 8px; border-left: 4px solid #10b981;">
        <h3 style="color: #065f46; margin-top: 0;">Time Complexity</h3>
        <ul style="margin: 0; padding-left: 20px; font-size: 14px;">
          <li><strong>Preprocessing:</strong> O(m) - Building failure function</li>
          <li><strong>Searching:</strong> O(n) - Pattern matching</li>
          <li><strong>Overall:</strong> O(n + m) - Linear time</li>
        </ul>
      </div>
      
      <div style="background: white; padding: 15px; border-radius: 8px; border-left: 4px solid #3b82f6;">
        <h3 style="color: #1e40af; margin-top: 0;">Space Complexity</h3>
        <ul style="margin: 0; padding-left: 20px; font-size: 14px;">
          <li><strong>Failure Function:</strong> O(m) - Array of pattern length</li>
          <li><strong>Variables:</strong> O(1) - Constant extra space</li>
          <li><strong>Overall:</strong> O(m) - Linear space</li>
        </ul>
      </div>
    </div>
  </div>

  <!-- Applications -->
  <div style="background: #f0f9ff; border-left: 4px solid #0ea5e9; padding: 20px; margin: 25px 0; border-radius: 0 8px 8px 0;">
    <h2 style="color: #0c4a6e; margin-top: 0;">üöÄ Real-World Applications</h2>
    
    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px;">
      <div style="background: white; padding: 15px; border-radius: 8px;">
        <h3 style="color: #dc2626; margin-top: 0;">üîç Text Editors</h3>
        <p style="margin: 0; font-size: 14px;">Find and replace operations in code editors and word processors</p>
      </div>
      
      <div style="background: white; padding: 15px; border-radius: 8px;">
        <h3 style="color: #059669; margin-top: 0;">üß¨ Bioinformatics</h3>
        <p style="margin: 0; font-size: 14px;">DNA sequence matching and protein pattern recognition</p>
      </div>
      
      <div style="background: white; padding: 15px; border-radius: 8px;">
        <h3 style="color: #7c3aed; margin-top: 0;">üîí Security</h3>
        <p style="margin: 0; font-size: 14px;">Intrusion detection systems and malware signature matching</p>
      </div>
      
      <div style="background: white; padding: 15px; border-radius: 8px;">
        <h3 style="color: #ea580c; margin-top: 0;">üåê Web Search</h3>
        <p style="margin: 0; font-size: 14px;">Substring search in search engines and web crawlers</p>
      </div>
    </div>
  </div>
</div>

<script>
class KMPVisualization {
    constructor() {
        this.text = "ABABDABACDABABCABCABCABCABC";
        this.pattern = "ABCABCABC";
        this.failure = [];
        this.isAnimating = false;
        this.animationSpeed = 1000;
        
        // Animation states
        this.failureStep = 0;
        this.searchStep = 0;
        this.textIndex = 0;
        this.patternIndex = 0;
        this.matches = [];
        
        this.initializeEventListeners();
        this.initializeVisualization();
    }
    
    initializeEventListeners() {
        // Input configuration
        document.getElementById('updateInputBtn').addEventListener('click', () => {
            this.text = document.getElementById('textInput').value;
            this.pattern = document.getElementById('patternInput').value;
            this.resetAll();
            this.initializeVisualization();
        });
        
        // Failure function controls
        document.getElementById('buildFailureBtn').addEventListener('click', () => this.startFailureFunctionAnimation());
        document.getElementById('resetFailureBtn').addEventListener('click', () => this.resetFailureFunction());
        document.getElementById('stepFailureBtn').addEventListener('click', () => this.stepFailureFunction());
        
        // Search controls
        document.getElementById('searchBtn').addEventListener('click', () => this.startSearchAnimation());
        document.getElementById('pauseSearchBtn').addEventListener('click', () => this.pauseAnimation());
        document.getElementById('resetSearchBtn').addEventListener('click', () => this.resetSearch());
        document.getElementById('stepSearchBtn').addEventListener('click', () => this.stepSearch());
    }
    
    initializeVisualization() {
        this.renderFailureFunctionVisualization();
        this.renderSearchVisualization();
    }
    
    // Failure Function Methods
    buildFailureFunction(pattern) {
        const failure = new Array(pattern.length).fill(0);
        let j = 0;
        
        for (let i = 1; i < pattern.length; i++) {
            while (j > 0 && pattern[i] !== pattern[j]) {
                j = failure[j - 1];
            }
            
            if (pattern[i] === pattern[j]) {
                j++;
            }
            
            failure[i] = j;
        }
        
        return failure;
    }
    
    renderFailureFunctionVisualization() {
        const container = document.getElementById('failureVisualization');
        
        if (this.pattern.length === 0) {
            container.innerHTML = '<div style="text-align: center; color: #6b7280;">Please enter a pattern</div>';
            return;
        }
        
        let html = '<div style="display: flex; flex-direction: column; align-items: center; gap: 20px;">';
        
        // Pattern display
        html += '<div style="display: flex; flex-direction: column; align-items: center; gap: 10px;">';
        html += '<div style="font-weight: bold; font-size: 16px;">Pattern:</div>';
        html += '<div style="display: flex; gap: 2px;">';
        
        for (let i = 0; i < this.pattern.length; i++) {
            const isActive = i <= this.failureStep && this.failureStep < this.pattern.length;
            const bgColor = isActive ? '#3b82f6' : '#e5e7eb';
            const textColor = isActive ? 'white' : '#374151';
            
            html += `<div style="width: 40px; height: 40px; background: ${bgColor}; color: ${textColor}; 
                     display: flex; align-items: center; justify-content: center; border-radius: 8px; 
                     font-weight: bold; font-family: monospace;">${this.pattern[i]}</div>`;
        }
        html += '</div>';
        
        // Index display
        html += '<div style="display: flex; gap: 2px;">';
        for (let i = 0; i < this.pattern.length; i++) {
            html += `<div style="width: 40px; text-align: center; font-size: 12px; color: #6b7280;">${i}</div>`;
        }
        html += '</div>';
        html += '</div>';
        
        // Failure function array
        if (this.failure.length > 0) {
            html += '<div style="display: flex; flex-direction: column; align-items: center; gap: 10px;">';
            html += '<div style="font-weight: bold; font-size: 16px;">Failure Function:</div>';
            html += '<div style="display: flex; gap: 2px;">';
            
            for (let i = 0; i < this.pattern.length; i++) {
                const value = i < this.failure.length ? this.failure[i] : '?';
                const isComputed = i < this.failure.length;
                const bgColor = isComputed ? '#10b981' : '#f3f4f6';
                const textColor = isComputed ? 'white' : '#9ca3af';
                
                html += `<div style="width: 40px; height: 40px; background: ${bgColor}; color: ${textColor}; 
                         display: flex; align-items: center; justify-content: center; border-radius: 8px; 
                         font-weight: bold; font-family: monospace;">${value}</div>`;
            }
            html += '</div>';
            html += '</div>';
        }
        
        html += '</div>';
        container.innerHTML = html;
    }
    
    startFailureFunctionAnimation() {
        if (this.isAnimating) return;
        
        this.resetFailureFunction();
        this.isAnimating = true;
        this.failure = [0]; // First element is always 0
        this.failureStep = 0;
        
        this.animateFailureFunction();
    }
    
    animateFailureFunction() {
        if (!this.isAnimating || this.failureStep >= this.pattern.length - 1) {
            this.isAnimating = false;
            this.updateFailureStepInfo("Failure function construction completed!");
            return;
        }
        
        this.stepFailureFunction();
        setTimeout(() => this.animateFailureFunction(), this.animationSpeed);
    }
    
    stepFailureFunction() {
        if (this.failure.length === 0) {
            this.failure = [0];
            this.failureStep = 0;
        }
        
        if (this.failureStep >= this.pattern.length - 1) return;
        
        this.failureStep++;
        const i = this.failureStep;
        let j = this.failure[i - 1];
        
        // Handle mismatches
        while (j > 0 && this.pattern[i] !== this.pattern[j]) {
            j = this.failure[j - 1];
        }
        
        // If characters match, increment j
        if (this.pattern[i] === this.pattern[j]) {
            j++;
        }
        
        this.failure[i] = j;
        
        this.updateFailureStepInfo(`Step ${i}: Comparing pattern[${i}]='${this.pattern[i]}' with pattern[${j-1}]='${this.pattern[j-1] || 'N/A'}', failure[${i}] = ${j}`);
        this.renderFailureFunctionVisualization();
    }
    
    resetFailureFunction() {
        this.isAnimating = false;
        this.failure = [];
        this.failureStep = 0;
        this.updateFailureStepInfo("Click 'Build Failure Function' to start construction");
        this.renderFailureFunctionVisualization();
    }
    
    updateFailureStepInfo(message) {
        document.getElementById('failureStepInfo').textContent = message;
    }
    
    // Search Methods
    renderSearchVisualization() {
        const container = document.getElementById('searchVisualization');
        
        if (this.text.length === 0 || this.pattern.length === 0) {
            container.innerHTML = '<div style="text-align: center; color: #6b7280;">Please enter both text and pattern</div>';
            return;
        }
        
        let html = '<div style="display: flex; flex-direction: column; gap: 20px; align-items: center;">';
        
        // Text display
        html += '<div style="display: flex; flex-direction: column; gap: 10px; align-items: center;">';
        html += '<div style="font-weight: bold; font-size: 16px;">Text:</div>';
        html += '<div style="display: flex; gap: 1px; flex-wrap: wrap; justify-content: center;">';
        
        for (let i = 0; i < this.text.length; i++) {
            let bgColor = '#f3f4f6';
            let textColor = '#374151';
            
            // Highlight current comparison
            if (i === this.textIndex) {
                bgColor = '#fbbf24';
                textColor = 'white';
            }
            
            // Highlight matches
            if (this.matches.some(match => i >= match && i < match + this.pattern.length)) {
                bgColor = '#10b981';
                textColor = 'white';
            }
            
            html += `<div style="width: 30px; height: 30px; background: ${bgColor}; color: ${textColor}; 
                     display: flex; align-items: center; justify-content: center; border-radius: 4px; 
                     font-weight: bold; font-family: monospace; font-size: 12px;">${this.text[i]}</div>`;
        }
        html += '</div>';
        
        // Index display for text
        html += '<div style="display: flex; gap: 1px; flex-wrap: wrap; justify-content: center;">';
        for (let i = 0; i < this.text.length; i++) {
            html += `<div style="width: 30px; text-align: center; font-size: 10px; color: #6b7280;">${i}</div>`;
        }
        html += '</div>';
        html += '</div>';
        
        // Pattern display
        if (this.textIndex >= 0) {
            html += '<div style="display: flex; flex-direction: column; gap: 10px; align-items: center;">';
            html += '<div style="font-weight: bold; font-size: 16px;">Pattern (aligned):</div>';
            html += '<div style="display: flex; gap: 1px; flex-wrap: wrap; justify-content: center;">';
            
            // Add spacing to align pattern
            const startPos = Math.max(0, this.textIndex - this.patternIndex);
            for (let i = 0; i < startPos; i++) {
                html += '<div style="width: 30px; height: 30px;"></div>';
            }
            
            // Pattern characters
            for (let i = 0; i < this.pattern.length; i++) {
                let bgColor = '#e5e7eb';
                let textColor = '#374151';
                
                if (i === this.patternIndex) {
                    bgColor = '#ef4444';
                    textColor = 'white';
                } else if (i < this.patternIndex) {
                    bgColor = '#10b981';
                    textColor = 'white';
                }
                
                html += `<div style="width: 30px; height: 30px; background: ${bgColor}; color: ${textColor}; 
                         display: flex; align-items: center; justify-content: center; border-radius: 4px; 
                         font-weight: bold; font-family: monospace; font-size: 12px;">${this.pattern[i]}</div>`;
            }
            html += '</div>';
            html += '</div>';
        }
        
        html += '</div>';
        container.innerHTML = html;
    }
    
    startSearchAnimation() {
        if (this.isAnimating) return;
        
        // Build failure function first if not already built
        if (this.failure.length === 0) {
            this.failure = this.buildFailureFunction(this.pattern);
        }
        
        this.resetSearch();
        this.isAnimating = true;
        this.animateSearch();
    }
    
    animateSearch() {
        if (!this.isAnimating || this.textIndex >= this.text.length) {
            this.isAnimating = false;
            this.showSearchResults();
            return;
        }
        
        this.stepSearch();
        setTimeout(() => this.animateSearch(), this.animationSpeed);
    }
    
    stepSearch() {
        if (this.textIndex >= this.text.length) return;
        
        // Handle mismatches using failure function
        while (this.patternIndex > 0 && this.text[this.textIndex] !== this.pattern[this.patternIndex]) {
            this.patternIndex = this.failure[this.patternIndex - 1];
            this.updateSearchStepInfo(`Mismatch! Using failure function: pattern index jumps to ${this.patternIndex}`);
            this.renderSearchVisualization();
            return;
        }
        
        // If characters match
        if (this.text[this.textIndex] === this.pattern[this.patternIndex]) {
            this.patternIndex++;
            this.updateSearchStepInfo(`Match! text[${this.textIndex}] = pattern[${this.patternIndex-1}] = '${this.text[this.textIndex]}'`);
        } else {
            this.updateSearchStepInfo(`Mismatch: text[${this.textIndex}] = '${this.text[this.textIndex]}' ‚â† pattern[${this.patternIndex}] = '${this.pattern[this.patternIndex]}'`);
        }
        
        // Check for complete match
        if (this.patternIndex === this.pattern.length) {
            const matchStart = this.textIndex - this.pattern.length + 1;
            this.matches.push(matchStart);
            this.updateSearchStepInfo(`Pattern found at position ${matchStart}!`);
            this.patternIndex = this.failure[this.patternIndex - 1];
        }
        
        this.textIndex++;
        this.renderSearchVisualization();
    }
    
    resetSearch() {
        this.isAnimating = false;
        this.textIndex = 0;
        this.patternIndex = 0;
        this.matches = [];
        this.updateSearchStepInfo("Click 'Start Search' to begin pattern matching");
        this.renderSearchVisualization();
        document.getElementById('searchResults').style.display = 'none';
    }
    
    pauseAnimation() {
        this.isAnimating = false;
    }
    
    updateSearchStepInfo(message) {
        document.getElementById('searchStepInfo').textContent = message;
    }
    
    showSearchResults() {
        const resultsContainer = document.getElementById('searchResults');
        const resultsContent = document.getElementById('resultsContent');
        
        if (this.matches.length === 0) {
            resultsContent.innerHTML = '<div style="color: #dc2626; font-weight: bold;">No matches found.</div>';
        } else {
            let html = `<div style="color: #065f46; font-weight: bold; margin-bottom: 10px;">Found ${this.matches.length} match(es):</div>`;
            html += '<ul style="margin: 0; padding-left: 20px;">';
            this.matches.forEach(match => {
                html += `<li>Pattern found at index ${match}</li>`;
            });
            html += '</ul>';
            resultsContent.innerHTML = html;
        }
        
        resultsContainer.style.display = 'block';
        this.updateSearchStepInfo(`Search completed! Found ${this.matches.length} match(es).`);
    }
    
    resetAll() {
        this.resetFailureFunction();
        this.resetSearch();
    }
}

// Initialize the visualization when the page loads
document.addEventListener('DOMContentLoaded', () => {
    new KMPVisualization();
});
</script>
